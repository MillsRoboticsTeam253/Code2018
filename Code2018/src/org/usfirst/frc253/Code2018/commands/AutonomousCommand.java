 // RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc253.Code2018.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import jaci.pathfinder.Trajectory;

import java.util.ArrayList;

import org.usfirst.frc253.Code2018.Robot;
import org.usfirst.frc253.Code2018.Robot.Goal;
import org.usfirst.frc253.Code2018.Robot.Position;
import org.usfirst.frc253.Code2018.profiles.MotionProfileData;
import org.usfirst.frc253.Code2018.profiles.ProfileLib;
import org.usfirst.frc253.Code2018.profiles.TrajecLib;
import org.usfirst.frc253.Code2018.profiles.TrajectoryContainer;

/**
 *
 */
public class AutonomousCommand extends CommandGroup {

	//So in this command, there is both the decision making for the robot and there is also
	//what the robot will do depending on the situation it is in
	
	/*TODO THIS IS A BIG TODO
	 *Auto sequence rn assumes that our allies will not run into us
	 *We need to implement something in the future to account for that
	 */
    public AutonomousCommand(Position position, Goal goal, boolean isSideSwitch, String gameData){
    	char switchSide = gameData.charAt(0); //L for Left, R for Right (relative to our alliance station)
    	char scaleSide = gameData.charAt(1);
    	
    	String autoStatus = "nothing";
    	addSequential(new elevatorUp(0.3));
    	
    	if(position == Position.CENTER){
    		switch(goal){
    			case SWITCH:
    				if(isSideSwitch){
	    				if(switchSide == 'L'){
	    					addSequential(new ScoreSwitch(new GoTo(ProfileLib.CtoLSwitchFaster, 6)));
	    				} else if(switchSide == 'R') {
	    					addSequential(new ScoreSwitch(new GoTo(ProfileLib.CtoRSwitchFaster, 6)));
	    				}
	    				addSequential(new Ejecthalf(1));
	    				addSequential(new elevatorDown(4));
	    				autoStatus = "center position to switch";
	    				break;
    				} else {
    					goal = Goal.EXCHANGE;
    				}
    			case EXCHANGE:
    				addSequential(new GoTo(ProfileLib.CtoExchange, 6));
    				addSequential(new Eject(1));
    				if(switchSide == 'L'){
    					addSequential(new GoTo(ProfileLib.ExchangetoRBase, 7));
    				} else if(switchSide == 'R') {
    					addSequential(new GoTo(ProfileLib.ExchangetoLBase, 6));
    				}
    				autoStatus = "center position to exchange";
    				break;
    			default:
    				if(switchSide == 'L'){
    					addSequential(new GoTo(ProfileLib.CtoRSwitchFaster, 6));
    				} else if(switchSide == 'R') {
    					addSequential(new GoTo(ProfileLib.CtoLSwitchFaster, 6));
    				}
    				autoStatus = "center position to baseline";
    				break;
    		}
    	} else if(position == Position.LEFT || position == Position.RIGHT){
    		switch(goal){
    			case SCALE:
    				if(scaleSide == position.getPos()){
    					if(position == Position.LEFT){
    						addSequential(new GoTo(ProfileLib.NewLtoLScale, 10));
    						autoStatus = "left position to scale";
    					} else if(position == Position.RIGHT){
    						addSequential(new GoTo(ProfileLib.NewRtoRScale, 10));
    						autoStatus = "right position to scale";
    					}
    					addSequential(new elevatorUp(4));
    					addSequential(new Eject(1));
    					addSequential(new elevatorDown(8));
    					break;
    				} else {
    					goal = Goal.SWITCH;
    				}
    			case SWITCH:
    				if(switchSide == position.getPos()){
    					if(position == Position.LEFT){
    						addSequential(new ScoreSwitch(new GoTo(ProfileLib.NewLtoLSwitch, 6)));
    						autoStatus = "left position to switch";
    					} else if(position == Position.RIGHT){
    						addSequential(new ScoreSwitch(new GoTo(ProfileLib.NewRToRSwitch, 6)));
    						autoStatus = "right position to switch";
    					}
	    				addSequential(new Ejecthalf(1));
	    				addSequential(new elevatorDown(4));
    					break;
    				} else {
    					goal = Goal.BASELINE;
    				}
    			case BASELINE:
    				addSequential(new StraightDrive());
    				autoStatus = "long baseline";
    				break;
    			default:
    				addSequential(new StraightDrive());
    				autoStatus = "long baseline";
    				break;
    		}
    	}
    	
    	SmartDashboard.putString("Auto Status", autoStatus);
    }    
    
    public AutonomousCommand(ArrayList<MotionProfileData> path, double timeout){
    	if(path.equals(ProfileLib.Straight15ftSlower)){
    		addSequential(new SolenoidsForward());
    	}
    	addSequential(new GoTo(path, timeout));
    }
    
    public AutonomousCommand(TrajectoryContainer container){
    	if(container.getTrajec().equals(TrajecLib.Straight15ft)){
    		addSequential(new SolenoidsForward());
    	}
    	addSequential(new GoToTrajec(container));
    }
}
