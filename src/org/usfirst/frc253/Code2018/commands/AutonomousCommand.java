 // RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc253.Code2018.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import jaci.pathfinder.Trajectory;

import java.util.ArrayList;

import org.usfirst.frc253.Code2018.Robot;
import org.usfirst.frc253.Code2018.Robot.AutoMode;
import org.usfirst.frc253.Code2018.Robot.Goal;
import org.usfirst.frc253.Code2018.Robot.Position;
import org.usfirst.frc253.Code2018.Robot.Priority;
import org.usfirst.frc253.Code2018.profiles.TrajecLib;
import org.usfirst.frc253.Code2018.profiles.TrajectoryContainer;

/**
 *
 */
public class AutonomousCommand extends CommandGroup {

	//So in this command, there is both the decision making for the robot and there is also
	//what the robot will do depending on the situation it is in
	
    public AutonomousCommand(Position position, Goal goal, boolean isSideSwitch, String gameData, AutoMode autoMode, Priority priority){
    	char switchSide = gameData.charAt(0); //L for Left, R for Right (relative to our alliance station)
    	char scaleSide = gameData.charAt(1);
    	
    	String autoStatus = "nothing";
    	addSequential(new SolenoidIntakeForward(0.1));
    	addSequential(new elevatorUp(0.2));
    	
    	if(position == Position.CENTER){
    		switch(goal){
    			case SWITCH:
    				if(isSideSwitch){
    					autoStatus = "center position to switch";
    					addSequential(new ScoreSwitch(new GoToTrajec(new TrajectoryContainer(TrajecLib.CtoRSwitch, switchSide == 'L'))));
	    				
    					if(autoMode == AutoMode.EXP){
        					addParallel(new elevatorDown(4));
    						addSequential(new GoToTrajecReverse(new TrajectoryContainer(TrajecLib.CtoRSwitch, switchSide == 'L')));
    						addSequential(new GoToTrajec(new TrajectoryContainer(TrajecLib.CtoCube, false)));
    						addSequential(new GetCube());
    						addSequential(new GoToTrajecReverse(new TrajectoryContainer(TrajecLib.CtoCube, false)));
    						addSequential(new ScoreSwitch(new GoToTrajec(new TrajectoryContainer(TrajecLib.CtoRSwitch, switchSide == 'L'))));
    						addSequential(new DriveBackwards(0.5));
        					addSequential(new elevatorDown(4));
    					} else {
    						addSequential(new DriveBackwards(0.5));
        					addSequential(new elevatorDown(4));
    					}
    					
    					break;
    				} else {
    					goal = Goal.EXCHANGE;
    				}
    			case EXCHANGE:
    			//	addSequential(new GoTo(ProfileLib.CtoExchange, 6));
    			//	addSequential(new Eject(1));
    				if(switchSide == 'L'){
    				//	addSequential(new GoTo(ProfileLib.ExchangetoRBase, 7));
    				} else if(switchSide == 'R') {
    					//addSequential(new GoTo(ProfileLib.ExchangetoLBase, 6));
    				}
    				autoStatus = "center position to exchange";
    			//	break;
    			default:
    				autoStatus = "center position to baseline";
    				addSequential(new GoToTrajec(new TrajectoryContainer(TrajecLib.CtoRSwitch, switchSide == 'R')));
    				break;
    		}
    	} else if(position == Position.LEFT || position == Position.RIGHT){
    		switch(goal){
    			case SCALE:
    				if(scaleSide == position.getPos()){
    					addSequential(new GoToTrajec(new TrajectoryContainer(TrajecLib.RtoRScale, position == Position.LEFT)));
    					addSequential(new ScoreScale());
    					
    					if(autoMode == AutoMode.EXP){
    						addSequential(new GoToTrajecReverse(new TrajectoryContainer(TrajecLib.BackuptoRScale, position == Position.LEFT)));
    						addSequential(new GoToTrajec(new TrajectoryContainer(TrajecLib.BackuptoRCube, position == Position.LEFT)));
    						addSequential(new GetCube());
    						addSequential(new elevatorUp(0.2));
    						addSequential(new GoToTrajecReverse(new TrajectoryContainer(TrajecLib.BackuptoRCube, position == Position.LEFT)));
    						addSequential(new GoToTrajec(new TrajectoryContainer(TrajecLib.BackuptoRScale, position == Position.LEFT)));
    						addSequential(new ScoreScale());
    					}
    					
    					break;
    				} else {
    					if(autoMode == AutoMode.EXP){
    						addSequential(new GoToTrajec(new TrajectoryContainer(TrajecLib.RtoLScale, position == Position.LEFT)));
    						addSequential(new ScoreScale());
    						break;
    					} else {
    						if(priority == Priority.BASELINE){
    							goal = Goal.BASELINE;
    						} else {
    							goal = Goal.SWITCH;
    						}
    					}
    				}
    			case SWITCH:
    				if(switchSide == position.getPos()){
    					autoStatus = "side to switch";
    					addSequential(new ScoreSwitch(new GoToTrajec(new TrajectoryContainer(TrajecLib.RtoRSwitch, position == Position.LEFT), 6)));
    					
    					if(autoMode == AutoMode.EXP){
        					addParallel(new elevatorDown(4));
    						addSequential(new GoToTrajecReverse(new TrajectoryContainer(TrajecLib.CtoRSwitch, switchSide == 'L')));
    						addSequential(new GoToTrajec(new TrajectoryContainer(TrajecLib.CtoCube, false)));
    						addSequential(new GetCube());
    						addSequential(new GoToTrajecReverse(new TrajectoryContainer(TrajecLib.CtoCube, false)));
    						addSequential(new ScoreSwitch(new GoToTrajec(new TrajectoryContainer(TrajecLib.CtoRSwitch, switchSide == 'L'))));
    						addSequential(new DriveBackwards(0.5));
        					addSequential(new elevatorDown(4));
    					} else {
    						addSequential(new DriveBackwards(0.5));
        					addSequential(new elevatorDown(4));
    					}
    					
    					break;
    				} else {
    					goal = Goal.BASELINE;
    				}
    			default:
    				autoStatus = "long baseline";
    				addSequential(new StraightDrive());
    				break;
    		}
    	}
    	
    	SmartDashboard.putString("Auto Status", autoStatus);
    }    
    
   /* public AutonomousCommand(ArrayList<MotionProfileData> path, double timeout){
    	if(path.equals(ProfileLib.Straight15ftSlower)){
    		addSequential(new SolenoidsForward());
    	}
    	addSequential(new GoTo(path, timeout));
    }*/
    
    public AutonomousCommand(TrajectoryContainer container, boolean reverse){
    	if(container.getTrajec().equals(TrajecLib.Straight15ft)){
    		addSequential(new SolenoidShiftForward());
    	}
    	
    	if(reverse){
    		addSequential(new GoToTrajecReverse(container));
    	} else {
    		addSequential(new GoToTrajec(container));
    	}
    }
    
    public AutonomousCommand(Trajectory trajec, boolean reverse){
    	addSequential(new SetElevator(trajec));
    	addSequential(new ElevatorHold(3));
    	addSequential(new elevatorDown(6));
    }
}
